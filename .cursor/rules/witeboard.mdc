# Witeboard — Distributed Global Whiteboard

## Project Overview

A minimalist, globally shared, real-time virtual whiteboard. Think Excalidraw/Figma meets Paint/Canva, but every user worldwide shares the same canvas. Future support for private breakout-room style group whiteboards.

## Core Invariant (Embed Everywhere)

**The server assigns the only authoritative order per board; clients deterministically replay immutable drawing events to render each board.**

Rules:
- Never sync pixels
- Never diff the DOM for drawing
- Replay operations → pixels are a side effect
- The server assigns authoritative ordering (seq) for every board

## Tech Stack

### Frontend
- Vite + React + TypeScript
- React Router: `/`, `/login`, `/b/:boardId`
- State store: Zustand (for presence + auth only, NOT canvas state)
- Canvas rendering: Imperative module (NOT React state)
- requestAnimationFrame for cursor overlay

### Backend
- Node.js + TypeScript
- `ws` WebSocket server
- Postgres (boards + drawing_events tables)
- Future: Redis Pub/Sub for horizontal scaling

### Auth
- Anonymous identity by default (works without auth configured)
- Clerk for user authentication (optional)
- Private boards require signed-in users

## Architecture Rules

### React Usage (CRITICAL)
React is used ONLY for:
- App shell (navbar, login page, layout)
- Side user list card
- Routing
- Small controls

**Canvas engine is imperative and must NOT store points in React state.**
**React re-renders must not drive drawing.**

### Canvas Rendering (Three Layers)
1. **Canvas 1: History** — Rasterized past strokes + snapshot
2. **Canvas 2: Live** — Current stroke being drawn (optimistic)
3. **Canvas 3: Cursor overlay** — Remote user presence indicators

Rendering rules:
- Never re-render full history per frame
- Append-only draw operations to history canvas
- Cursor overlay: cleared/redrawn each animation frame
- On pan/zoom: redraw everything with viewport transform

### Viewport (Pan/Zoom)
```typescript
interface Viewport {
  offsetX: number  // Pan offset in screen pixels
  offsetY: number
  scale: number    // Zoom level (1 = 100%, range 0.1-5)
}
```
- All strokes stored in **world coordinates**
- Viewport is **local only** (not synced between clients)
- `screenToWorld()` / `worldToScreen()` convert between coordinate systems
- `redrawAll()` applies viewport transform when rendering

### Snapshot Compaction (Server-side)
- Server renders events to a PNG image (using node-canvas)
- Snapshot stored in `board_snapshots` table with seq number
- Client loads snapshot image first, then replays events after it
- Snapshots use **transparent background** (client CSS provides background)
- On pan/zoom, snapshot is redrawn with viewport transform

### Client State (Imperative Module — `canvas/state.ts`)
```typescript
// These must NOT live in React component state
drawLog: DrawEvent[]              // Authoritative replay log for current board
pendingStroke: PendingStroke | null  // Optimistic local stroke being drawn
pendingShape: PendingShape | null    // Optimistic shape being drawn
cursors: Map<userId, RemoteCursor>   // Ephemeral presence (world coords)
deletedStrokeIds: Set<string>        // Tracks deleted strokes for replay filtering
strokeBoundsMap: Map<strokeId, Bounds>  // Hit-testing for eraser
snapshotImage: HTMLImageElement | null  // Loaded snapshot for redraw
viewport: Viewport                   // Local pan/zoom state (not synced)
undoStack: string[]                  // User's own strokeIds for undo
```

### Drawing Flow
1. `pointerdown` → start stroke
2. `pointermove` → collect points + draw locally (optimistic)
3. `pointerup` → send stroke event to server
4. Server assigns `seq`, persists, broadcasts
5. Client receives authoritative event, reconciles with optimistic

## Data Models

### DrawEvent (Immutable, Append-only)
```typescript
interface DrawEvent {
  boardId: string
  seq: number           // Server-assigned, authoritative
  type: 'stroke' | 'shape' | 'text' | 'delete' | 'clear'
  userId: string
  timestamp: number
  payload: StrokePayload | ShapePayload | TextPayload | DeletePayload | ClearPayload
}

// Stroke payload (pencil, marker, brush)
interface StrokePayload {
  strokeId: string
  color: string
  width: number
  opacity: number
  points: [number, number][]  // World coordinates
}

// Shape payload (rectangle, ellipse, line)
interface ShapePayload {
  strokeId: string
  shapeType: 'rectangle' | 'ellipse' | 'line'
  start: [number, number]
  end: [number, number]
  color: string
  width: number
  opacity: number
}

// Text payload
interface TextPayload {
  strokeId: string
  text: string
  position: [number, number]
  color: string
  fontSize: number
}

// Delete payload (eraser, undo)
interface DeletePayload {
  strokeIds: string[]
}
```

### UserIdentity
```typescript
interface UserIdentity {
  userId: string
  displayName: string
  isAnonymous: boolean
  avatarColor?: string
}
```

### PresenceState
```typescript
interface PresenceState {
  boardId: string
  userId: string
  displayName: string
  isAnonymous: boolean
  cursor?: { x: number; y: number; t: number }
  connectedAt: number
}
```

## WebSocket Protocol

### Client → Server
- `HELLO` — Join board with identity (includes authToken for private boards)
- `DRAW_EVENT` — Submit stroke/shape/text/delete
- `CURSOR_MOVE` — Update cursor position (throttled 30-60ms)
- `CREATE_BOARD` — Create a new board (requires auth)
- `LEAVE_BOARD` — Optional explicit leave

### Server → Client
- `WELCOME` — Confirm identity assignment
- `SYNC_SNAPSHOT` — Initial sync with optional snapshot + events
  - `{ snapshot?: { imageData, seq }, events: DrawEvent[], isDelta?: boolean }`
  - Full sync: all events (no snapshot)
  - Snapshot sync: snapshot image + events after it
  - Delta sync: only new events since client's lastSeq
- `DRAW_EVENT` — Authoritative broadcasted event
- `CURSOR_MOVE` — Single cursor update (legacy)
- `CURSOR_BATCH` — Batched cursor updates (preferred)
- `USER_LIST` — Full presence list
- `USER_JOIN` — User joined board
- `USER_LEAVE` — User left board
- `BOARD_CREATED` — New board created successfully
- `ACCESS_DENIED` — User denied access to private board
- `ERROR` — Error response

## Database Schema (Postgres)

```sql
CREATE TABLE boards (
  id TEXT PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  name TEXT,
  owner_id TEXT,                -- Clerk user ID (null for public boards)
  is_private BOOLEAN DEFAULT false
);

CREATE TABLE drawing_events (
  board_id TEXT NOT NULL REFERENCES boards(id),
  seq BIGINT NOT NULL,
  event JSONB NOT NULL,
  PRIMARY KEY (board_id, seq)
);

-- Snapshot compaction cache (one per board)
CREATE TABLE board_snapshots (
  board_id TEXT PRIMARY KEY REFERENCES boards(id),
  seq BIGINT NOT NULL,          -- Sequence number snapshot covers up to
  image_data TEXT NOT NULL,     -- Base64-encoded PNG (transparent background)
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

## Routes
- `/` — Global public board (boardId="global")
- `/login` — Clerk auth flow
- `/boards` — User's board list (requires auth)
- `/b/:boardId` — Private or shared board

## UI Components

### Navbar
- Home link
- Login link (if anonymous) / Logout + Profile (if signed in)

### Side Card (User List)
- Current users on board
- Anonymous vs signed-in indicator
- Optional cursor color dot

## Explicit Non-Goals
- No CRDTs (server-assigned seq is simpler and sufficient)
- No SVG rendering (canvas only)
- No pixel diff syncing (event replay only)
- No moderation tools (initially)

## Implemented Features
- Undo (Ctrl/Cmd+Z) - deletes user's own strokes
- Private boards with Clerk authentication
- Eraser tool (click to delete strokes)
- Shape tools (rectangle, ellipse, line)
- Text tool
- Infinite canvas with pan/zoom
- Snapshot compaction (server-side image caching)

## Implementation Sequence
1. Frontend React shell (routes, navbar, layout)
2. WebSocket server skeleton (connection handling, message routing)
3. HELLO + presence (join rooms, USER_LIST/JOIN/LEAVE)
4. Persistence (Postgres schema, replay query)
5. Drawing pipeline (stroke capture, seq assignment, broadcast)
6. Cursor pipeline (throttled moves, overlay renderer)
7. Replay determinism validation
8. Optional: compaction (live → history merge)

## Performance Guidelines
- Throttle cursor updates to 30-60ms
- Compact strokes to history layer periodically
- Never re-render full history on each frame
- Use requestAnimationFrame for cursor overlay only

## Scaling Path
1. **MVP**: Single Node.js server, in-memory presence, managed Postgres
2. **Phase 2**: Multiple WS servers, sticky sessions, Redis Pub/Sub
3. **Phase 3**: Partition by boardId, snapshot compaction, event chunking

## Implementation Checklist (CRITICAL)

**BEFORE pushing ANY changes, run this sequence:**

```bash
# 1. Build locally (catches TS errors Railway will hit)
pnpm build

# 2. Check git status for uncommitted files  
git status

# 3. Stage ALL changes (including package.json, lockfiles, new files)
git add -A

# 4. Commit and push
git commit -m "feat: description"
git push origin main
```

### What Gets Missed (Common Failures)

| Symptom | Root Cause | What to Commit |
|---------|------------|----------------|
| `Cannot find module './path/File'` | New source file not committed | The `.tsx`/`.ts` file |
| `Cannot find module 'package-name'` | Dependency added but package.json not committed | `package.json` + `pnpm-lock.yaml` |
| `TS2345: Argument type mismatch` | Local dev uses esbuild (no type check), prod uses tsc | Fix types, run `pnpm build` |
| `ERR_MODULE_NOT_FOUND: ...shared/dist/...` | Shared package exports wrong path | Check `packages/shared/package.json` exports |

### Why This Happens
- **`pnpm add`** modifies `package.json` and `pnpm-lock.yaml` — both must be committed
- **New files** are untracked by default (`??` in git status)
- **Local dev** uses esbuild which skips type checking; **prod build** uses tsc which is strict

### Railway Environment Variables

| Variable | Type | Purpose |
|----------|------|---------|
| `DATABASE_URL` | Runtime (auto) | Postgres connection |
| `PORT` | Runtime (auto) | Server port |
| `CLERK_SECRET_KEY` | Runtime (manual) | Server token verification |
| `VITE_CLERK_PUBLISHABLE_KEY` | Build-time (manual) | Frontend auth UI |

**Common production issue:** `/api/boards` returns 401
- **Cause:** `CLERK_SECRET_KEY` not set in Railway variables
- **Fix:** Add it in Railway Dashboard → Variables

### Monorepo Build Order (Dockerfile)
1. `@witeboard/shared` → generates `dist/` with `.js` and `.d.ts`
2. `@witeboard/client` → runs `tsc` then Vite
3. `@witeboard/server` → runs `tsc`

Dependencies added to ANY package require committing the root `pnpm-lock.yaml`.

## Deployment

### Railway (Production)
- Single service deploys both frontend (static) + backend (Node.js)
- Postgres addon provides managed database
- `DATABASE_URL` auto-injected by Railway
- Dockerfile handles multi-stage build

### Build Process
```bash
# Development
pnpm dev          # Runs Vite dev server + tsx watch

# Production
pnpm build        # Builds client → dist/, compiles server
node dist/index.js  # Serves API + static files
```

### Environment Variables
| Variable | Required | Default | Description |
|----------|----------|---------|-------------|
| `DATABASE_URL` | Yes | — | PostgreSQL connection string |
| `PORT` | No | `3001` | HTTP/WebSocket server port |
| `NODE_ENV` | No | `development` | `production` enables static serving |

### Production Architecture
```
Railway Service
├── Node.js server (PORT)
│   ├── WebSocket: /ws or upgrade on same port
│   ├── Static files: Vite build served from /
│   └── SPA fallback: /* → index.html
└── Postgres (DATABASE_URL)
```

### Local Development Ports
- Frontend (Vite): http://localhost:5173
- Backend (WebSocket): ws://localhost:3001
- Postgres: localhost:5433 (Docker)
